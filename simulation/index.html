<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>RegEx to NFA Converter - Automata Theory</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css">
  <script src="mobile-detection.js"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          fontFamily: {
            'sans': ['Inter', 'system-ui', 'sans-serif'],
          },
          colors: {
            primary: '#3B82F6', // blue-500
            secondary: '#6366F1', // indigo-500
            accent: '#10B981', // green-500
            danger: '#EF4444', // red-500
            neutral: '#F3F4F6', // gray-100
          }
        }
      }
    }
  </script>
  <style>
    body {
      font-family: 'Inter', system-ui, sans-serif;
      background: #fff;
      min-height: 100vh;
      width: 100vw;
      max-width: 100vw;
      overflow-x: hidden;
      height: 100vh;
    }
    .glass-morphism {
      background: rgba(255, 255, 255, 0.85);
      backdrop-filter: blur(6px);
      border: 1px solid rgba(0, 0, 0, 0.04);
    }
    
    .dark-glass {
      background: rgba(243, 244, 246, 0.7);
      backdrop-filter: blur(6px);
      border: 1px solid rgba(0, 0, 0, 0.04);
    }
    
    .gradient-text {
      background: linear-gradient(135deg, #3B82F6, #6366F1);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .floating-card {
      transform: translateY(0);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .floating-card:hover {
      transform: translateY(-0.25rem);
      box-shadow: 0 1.25rem 2.5rem rgba(59, 130, 246, 0.08);
    }
    
    .neu-button {
      background: #fff;
      color: #374151;
      border: 1px solid #e5e7eb;
      box-shadow: 0 0.125rem 0.5rem rgba(59, 130, 246, 0.06);
      transition: all 0.2s ease;
      font-weight: 500;
      font-size: 1rem;
      padding: 0.75rem 1.5rem !important;
      min-width: 110px;
      min-height: 2.5rem;
      border-radius: 0.9rem !important;
    }
    .neu-button.primary {
      background: #3B82F6;
      color: #fff;
      border: none;
    }
    .neu-button.secondary {
      background: #6366F1;
      color: #fff;
      border: none;
    }
    .neu-button.accent {
      background: #10B981;
      color: #fff;
      border: none;
    }
    .neu-button.danger {
      background: #EF4444;
      color: #fff;
      border: none;
    }
    .neu-button:hover {
      filter: brightness(0.95);
      box-shadow: 0 0.25rem 1rem rgba(59, 130, 246, 0.10);
    }
    .neu-button:active {
      filter: brightness(0.90);
    }
    .neu-button:disabled {
      background: #e5e7eb !important;
      color: #9ca3af !important;
      border-color: #e5e7eb !important;
      cursor: not-allowed !important;
      filter: grayscale(0.5) brightness(0.97);
      box-shadow: none !important;
    }
    
    #regex-display {
      background: #F3F4F6;
      border-radius: 0.75rem;
      padding: 1rem;
      color: #1e293b;
      font-size: 1.5rem;
      text-align: center;
      min-height: 3rem;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: 'Courier New', monospace;
      font-weight: bold;
    }

    #step-canvas {
      width: 100% !important;
      max-width: 100%;
      height: 35vw !important;
      min-height: 280px;
      max-height: 400px;
      display: block;
      margin: auto;
      border-radius: 0.75rem;
      background: white;
      border: 2px solid #e5e7eb;
    }

    #steps-container {
      background: #F3F4F6;
      border-radius: 0.75rem;
      padding: 1rem;
      backdrop-filter: blur(6px);
      overflow-y: auto;
      max-height: 40vh;
      min-height: 15vh;
    }

    .step-item {
      background: #fff;
      border: 1px solid #e5e7eb;
      border-radius: 0.5rem;
      padding: 0.75rem;
      margin-bottom: 0.5rem;
      transition: all 0.3s ease;
    }

    .step-item.current {
      background: #eff6ff;
      border-color: #3b82f6;
      box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
    }

    .step-item.completed {
      background: #f0fdf4;
      border-color: #10b981;
    }

    .step-number {
      background: #6b7280;
      color: white;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: bold;
      margin-right: 0.5rem;
    }

    .step-item.current .step-number {
      background: #3b82f6;
    }

    .step-item.completed .step-number {
      background: #10b981;
    }

    .progress-bar {
      width: 100%;
      height: 6px;
      background: #e5e7eb;
      border-radius: 3px;
      margin: 1rem 0;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(135deg, #3B82F6, #6366F1);
      transition: width 0.3s ease;
    }

    body, .text-gray-800, .text-gray-700, .text-black, .panel-title, h2, h3, span, p, label, .font-semibold, .font-medium, .font-bold, .font-mono, .font-sans, .font-inter {
      color: #18181b !important;
    }
    
    .neu-button.primary, .neu-button.secondary, .neu-button.accent, .neu-button.danger {
      color: #fff !important;
    }

    .w-6.bg-primary .text-white, .w-6.bg-secondary .text-white, .w-6.bg-accent .text-white, .w-6.bg-danger .text-white {
      color: #fff !important;
    }

    @media (max-width: 768px) {
      #step-canvas {
        height: 45vw !important;
        min-height: 200px;
        max-height: 300px;
      }
      
      .floating-card, .glass-morphism, .dark-glass {
        padding: 0.75rem !important;
        margin-bottom: 0.5rem !important;
      }
      
      #regex-display {
        font-size: 1.2rem !important;
        padding: 0.75rem !important;
      }
    }
  </style>
</head>
<body class="text-gray-800 overflow-x-hidden bg-white">

  <!-- Quick Guide Panel -->
  <div class="floating-card glass-morphism rounded-2xl p-4 shadow-lg max-w-7xl mx-auto mb-4">
    <div class="flex items-center justify-between mb-3">
      <h2 class="text-lg font-semibold text-gray-800 flex items-center">
        <svg class="w-4 h-4 mr-2" fill="currentColor" viewBox="0 0 20 20">
          <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zm-2 5a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"></path>
        </svg>
        Thompson's Algorithm - Step by Step
      </h2>
    </div>
    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-3">
      <div class="dark-glass rounded-xl p-3 text-center">
        <div class="w-6 h-6 bg-primary rounded-full flex items-center justify-center mx-auto mb-2">
          <span class="text-white font-bold text-xs">1</span>
        </div>
        <p class="text-gray-700 text-xs">Enter a regular expression</p>
      </div>
      <div class="dark-glass rounded-xl p-3 text-center">
        <div class="w-6 h-6 bg-secondary rounded-full flex items-center justify-center mx-auto mb-2">
          <span class="text-white font-bold text-xs">2</span>
        </div>
        <p class="text-gray-700 text-xs">Start the construction process</p>
      </div>
      <div class="dark-glass rounded-xl p-3 text-center">
        <div class="w-6 h-6 bg-accent rounded-full flex items-center justify-center mx-auto mb-2">
          <span class="text-white font-bold text-xs">3</span>
        </div>
        <p class="text-gray-700 text-xs">Step through each operation</p>
      </div>
      <div class="dark-glass rounded-xl p-3 text-center">
        <div class="w-6 h-6 bg-danger rounded-full flex items-center justify-center mx-auto mb-2">
          <span class="text-white font-bold text-xs">4</span>
        </div>
        <p class="text-gray-700 text-xs">Test the final NFA</p>
      </div>
    </div>
  </div>

  <!-- Main Content Container -->
  <div class="max-w-7xl mx-auto px-4 pb-16 flex flex-col lg:flex-row gap-8 items-stretch min-h-[70vh]">
    <!-- Primary Control Panel and NFA Visualization -->
    <div class="flex-1 flex flex-col gap-6 justify-between min-w-0">
      <!-- Input & Controls Panel -->
      <div class="floating-card glass-morphism rounded-3xl p-4 mb-6 shadow-xl flex flex-col gap-3">
        <div class="flex flex-col md:flex-row md:items-end gap-3">
          <div class="flex-1">
            <div class="dark-glass rounded-2xl p-3 flex flex-col md:flex-row md:items-center gap-3">
              <div class="flex-1">
                <h3 class="text-base font-semibold text-gray-800 mb-1 flex items-center">
                  <svg class="w-5 h-5 mr-2" fill="currentColor" viewBox="0 0 20 20">
                    <path d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                  </svg>
                  Regular Expression
                </h3>
                <div class="bg-neutral rounded-xl p-2 backdrop-blur-sm">
                  <div id="regex-display">Enter a regex to begin</div>
                  <input type="text" id="regex-input" class="hidden w-full mt-2 p-2 border border-gray-300 rounded-lg font-mono" placeholder="e.g., (a|b)*abb">
                </div>
              </div>
              <div class="flex flex-wrap gap-2 md:gap-2 justify-end md:justify-start">
                <button onclick="showInputDialog()" class="neu-button primary px-2 py-1 rounded-xl font-medium text-xs transition-all hover:scale-105 active:scale-95 flex items-center gap-1">
                  <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                    <path d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z"></path>
                  </svg>
                  Enter RegEx
                </button>
                <button onclick="loadExample()" class="neu-button secondary px-2 py-1 rounded-xl font-medium text-xs transition-all hover:scale-105 active:scale-95 flex items-center gap-1">
                  <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 010 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z" clip-rule="evenodd"></path>
                  </svg>
                  Examples
                </button>
                <button id="prev-btn" onclick="previousStep()" disabled class="neu-button accent px-2 py-1 rounded-xl font-medium text-xs transition-all hover:scale-105 active:scale-95 flex items-center gap-1">
                  <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z" clip-rule="evenodd"></path>
                  </svg>
                  Previous
                </button>
                <button id="next-btn" onclick="nextStep()" disabled class="neu-button danger px-2 py-1 rounded-xl font-medium text-xs transition-all hover:scale-105 active:scale-95 flex items-center gap-1">
                  <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd"></path>
                  </svg>
                  Next Step
                </button>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Progress Bar -->
        <div id="progress-container" class="hidden">
          <div class="flex items-center justify-between mb-2">
            <span id="current-step-title" class="text-sm font-medium text-gray-700">Ready to begin</span>
            <span id="step-counter" class="text-xs text-gray-500">0 / 0</span>
          </div>
          <div class="progress-bar">
            <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
          </div>
          <p id="current-step-description" class="text-xs text-gray-600 mt-1">Click "Enter RegEx" to start</p>
        </div>

        <!-- NFA Visualization Panel -->
        <div class="dark-glass rounded-2xl p-3 flex-1 flex flex-col justify-between min-h-[300px] mt-2">
          <h3 class="text-base font-semibold text-gray-800 mb-2 flex items-center">
            <svg class="w-5 h-5 mr-2" fill="currentColor" viewBox="0 0 20 20">
              <path fill-rule="evenodd" d="M6 6V5a3 3 0 013-3h2a3 3 0 013 3v1h2a2 2 0 012 2v3.57A22.952 22.952 0 0110 13a22.95 22.95 0 01-8-1.43V8a2 2 0 012-2h2zm2-1a1 1 0 011-1h2a1 1 0 011 1v1H8V5zm1 5a1 1 0 011-1h.01a1 1 0 110 2H10a1 1 0 01-1-1z" clip-rule="evenodd"></path>
            </svg>
            NFA Construction
          </h3>
          <div class="bg-neutral rounded-xl p-2 backdrop-blur-sm flex-1 flex items-center justify-center min-h-[280px]">
            <svg id="canvas1" class="w-full h-full" style="min-height: 280px;"></svg>
          </div>
        </div>
      </div>
    </div>

    <!-- Steps Trace Sidebar -->
    <div class="lg:w-80 w-full mt-6 lg:mt-0 flex-shrink-0">
      <div class="dark-glass rounded-2xl p-6 h-full flex flex-col justify-between min-h-[500px]">
        <h3 class="text-lg font-semibold text-gray-800 mb-4 flex items-center">
          <svg class="w-5 h-5 mr-2" fill="currentColor" viewBox="0 0 20 20">
            <path d="M9 2a1 1 0 000 2h2a1 1 0 100-2H9z"></path>
            <path fill-rule="evenodd" d="M4 5a2 2 0 012-2v1a1 1 0 001 1h6a1 1 0 001-1V3a2 2 0 012 2v6a2 2 0 01-2 2H6a2 2 0 01-2-2V5zm3 4a1 1 0 000 2h.01a1 1 0 100-2H7zm3 0a1 1 0 000 2h3a1 1 0 100-2h-3zm-3 4a1 1 0 100 2h.01a1 1 0 100-2H7zm3 0a1 1 0 100 2h3a1 1 0 100-2h-3z" clip-rule="evenodd"></path>
          </svg>
          Construction Steps
        </h3>
        <div id="steps-container" class="flex-1 mb-4">
          <div id="steps-list">
            <p class="text-gray-500 text-center text-sm">Enter a regular expression to see construction steps</p>
          </div>
        </div>
        
        <!-- Test Section -->
        <div id="test-section" class="hidden">
          <h4 class="text-sm font-semibold text-gray-800 mb-2 flex items-center">
            <svg class="w-4 h-4 mr-2" fill="currentColor" viewBox="0 0 20 20">
              <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path>
            </svg>
            Test NFA
          </h4>
          <div class="flex gap-2 mb-2 flex-wrap">
            <input type="text" id="test-input" placeholder="Test string" class="flex-1 min-w-0 px-2 py-1 text-sm border border-gray-300 rounded">
            <button onclick="testString()" class="neu-button primary px-2 py-1 text-xs flex-shrink-0">Test</button>
          </div>
          <div id="test-result"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    class NFAState {
      constructor(id) {
        this.id = id;
        this.transitions = new Map();
        this.epsilonTransitions = new Set();
        this.isAccept = false;
      }

      addTransition(symbol, state) {
        if (!this.transitions.has(symbol)) {
          this.transitions.set(symbol, new Set());
        }
        this.transitions.get(symbol).add(state);
      }

      addEpsilonTransition(state) {
        this.epsilonTransitions.add(state);
      }
    }

    class NFA {
      constructor(start, accept) {
        this.start = start;
        this.accept = accept;
        
        if (accept) {
          accept.isAccept = true;
        }
        
        this.states = new Set();
        this.alphabet = new Set();
        
        if (start) {
          this.collectStates(start);
        }
      }

      collectStates(state, visited = new Set()) {
        if (!state || visited.has(state)) return;
        visited.add(state);
        this.states.add(state);

        if (state.transitions && state.transitions instanceof Map) {
          for (const [symbol, nextStates] of state.transitions) {
            if (symbol) this.alphabet.add(symbol);
            if (nextStates) {
              for (const nextState of nextStates) {
                if (nextState) {
                  this.collectStates(nextState, visited);
                }
              }
            }
          }
        }

        if (state.epsilonTransitions) {
          for (const nextState of state.epsilonTransitions) {
            if (nextState) {
              this.collectStates(nextState, visited);
            }
          }
        }
      }

      epsilonClosure(states) {
        const closure = new Set(states);
        const stack = [...states];

        while (stack.length > 0) {
          const state = stack.pop();
          for (const epsilonState of state.epsilonTransitions) {
            if (!closure.has(epsilonState)) {
              closure.add(epsilonState);
              stack.push(epsilonState);
            }
          }
        }

        return closure;
      }

      accepts(input) {
        let currentStates = this.epsilonClosure(new Set([this.start]));

        for (const symbol of input) {
          const nextStates = new Set();
          for (const state of currentStates) {
            if (state.transitions.has(symbol)) {
              for (const nextState of state.transitions.get(symbol)) {
                nextStates.add(nextState);
              }
            }
          }
          currentStates = this.epsilonClosure(nextStates);
        }

        return Array.from(currentStates).some(state => state.isAccept);
      }
    }

    class StepByStepConverter {
      constructor() {
        this.stateCounter = 0;
        this.steps = [];
        this.currentStepIndex = 0;
        this.isAutoPlaying = false;
      }

      createState() {
        return new NFAState(this.stateCounter++);
      }

      reset() {
        this.stateCounter = 0;
        this.steps = [];
        this.currentStepIndex = 0;
        this.isAutoPlaying = false;
      }

      parseRegex(regex) {
        this.reset();
        
        this.steps.push({
          title: "Original Regular Expression",
          description: `Input regex: ${regex}`,
          nfa: null,
          stack: [],
          operation: "start"
        });

        const tokens = this.tokenize(regex);
        this.steps.push({
          title: "Tokenization",
          description: `Broke regex into tokens: [${tokens.join(', ')}]`,
          nfa: null,
          stack: [],
          operation: "tokenize",
          tokens: tokens
        });

        const postfix = this.infixToPostfix(tokens);
        this.steps.push({
          title: "Convert to Postfix",
          description: `Converted to postfix notation: [${postfix.join(', ')}]`,
          nfa: null,
          stack: [],
          operation: "postfix",
          postfix: postfix
        });

        this.buildNFAStepByStep(postfix);
        return this.steps;
      }

      tokenize(regex) {
        return regex.split('');
      }

      infixToPostfix(tokens) {
        const output = [];
        const stack = [];
        const precedence = { '|': 1, '·': 2, '*': 3, '+': 3 };

        const withConcat = [];
        for (let i = 0; i < tokens.length; i++) {
          withConcat.push(tokens[i]);
          if (i < tokens.length - 1) {
            const curr = tokens[i];
            const next = tokens[i + 1];
            if (!'(|'.includes(curr) && !')|*+'.includes(next)) {
              withConcat.push('·');
            }
          }
        }

        for (const token of withConcat) {
          if (token === '(') {
            stack.push(token);
          } else if (token === ')') {
            while (stack.length && stack[stack.length - 1] !== '(') {
              output.push(stack.pop());
            }
            stack.pop();
          } else if ('|·*+'.includes(token)) {
            while (stack.length && stack[stack.length - 1] !== '(' &&
                   precedence[stack[stack.length - 1]] >= precedence[token]) {
              output.push(stack.pop());
            }
            stack.push(token);
          } else {
            output.push(token);
          }
        }

        while (stack.length) {
          output.push(stack.pop());
        }

        return output;
      }

      buildNFAStepByStep(postfix) {
        const stack = [];

        for (const token of postfix) {
          if (token === '|') {
            const nfa2 = stack.pop();
            const nfa1 = stack.pop();
            const result = this.union(nfa1, nfa2);
            stack.push(result);
            
            this.steps.push({
              title: "Union Operation (|)",
              description: `Combined two NFAs with union operator. Created new start and accept states with ε-transitions.`,
              nfa: result,
              stack: [...stack],
              operation: "union",
              operands: [nfa1, nfa2]
            });
          } else if (token === '·') {
            const nfa2 = stack.pop();
            const nfa1 = stack.pop();
            const result = this.concatenation(nfa1, nfa2);
            stack.push(result);
            
            this.steps.push({
              title: "Concatenation Operation (·)",
              description: `Connected two NFAs in sequence with ε-transition from first accept to second start.`,
              nfa: result,
              stack: [...stack],
              operation: "concat",
              operands: [nfa1, nfa2]
            });
          } else if (token === '*') {
            const nfa = stack.pop();
            const result = this.kleeneStar(nfa);
            stack.push(result);
            
            this.steps.push({
              title: "Kleene Star Operation (*)",
              description: `Applied * operator. Created new start/accept states with ε-transitions for zero or more repetitions.`,
              nfa: result,
              stack: [...stack],
              operation: "star",
              operands: [nfa]
            });
          } else if (token === '+') {
            const nfa = stack.pop();
            const result = this.plus(nfa);
            stack.push(result);
            
            this.steps.push({
              title: "Plus Operation (+)",
              description: `Applied + operator. Modified for one or more repetitions.`,
              nfa: result,
              stack: [...stack],
              operation: "plus",
              operands: [nfa]
            });
          } else {
            const result = this.symbol(token);
            stack.push(result);
            
            this.steps.push({
              title: `Symbol NFA for '${token}'`,
              description: `Created basic NFA with start state, accept state, and transition on symbol '${token}'.`,
              nfa: result,
              stack: [...stack],
              operation: "symbol",
              symbol: token
            });
          }
        }

        this.steps.push({
          title: "Construction Complete!",
          description: `Successfully converted regular expression to NFA. The final NFA has ${stack[0].states.size} states.`,
          nfa: stack[0],
          stack: stack,
          operation: "complete"
        });
      }

      symbol(char) {
        const start = this.createState();
        const accept = this.createState();
        start.addTransition(char, accept);
        return new NFA(start, accept);
      }

      concatenation(nfa1, nfa2) {
        nfa1.accept.addEpsilonTransition(nfa2.start);
        nfa1.accept.isAccept = false;
        return new NFA(nfa1.start, nfa2.accept);
      }

      union(nfa1, nfa2) {
        const start = this.createState();
        const accept = this.createState();

        start.addEpsilonTransition(nfa1.start);
        start.addEpsilonTransition(nfa2.start);

        nfa1.accept.addEpsilonTransition(accept);
        nfa2.accept.addEpsilonTransition(accept);

        nfa1.accept.isAccept = false;
        nfa2.accept.isAccept = false;

        return new NFA(start, accept);
      }

      kleeneStar(nfa) {
        const start = this.createState();
        const accept = this.createState();

        start.addEpsilonTransition(nfa.start);
        start.addEpsilonTransition(accept);

        nfa.accept.addEpsilonTransition(nfa.start);
        nfa.accept.addEpsilonTransition(accept);

        nfa.accept.isAccept = false;

        return new NFA(start, accept);
      }

      plus(nfa) {
        const start = this.createState();
        const accept = this.createState();

        start.addEpsilonTransition(nfa.start);
        nfa.accept.addEpsilonTransition(nfa.start);
        nfa.accept.addEpsilonTransition(accept);

        nfa.accept.isAccept = false;

        return new NFA(start, accept);
      }

      // Add SVG conversion helpers to StepByStepConverter
      getSvgDefinitionForStep(stepIndex) {
        if (!this.steps || stepIndex >= this.steps.length || stepIndex < 0) {
          return { vertices: [], edges: [] };
        }
        const step = this.steps[stepIndex];
        if (!step || !step.nfa) {
          return { vertices: [], edges: [] };
        }
        return this.convertNfaToSvgFormat(step.nfa);
      }

      getClosureStatesForStep(stepIndex) {
        if (!this.steps || stepIndex >= this.steps.length || stepIndex < 0) {
          return [];
        }
        const step = this.steps[stepIndex];
        if (!step || !step.nfa) {
          return [];
        }
        return step.nfa.start ? [step.nfa.start.id.toString()] : [];
      }

      convertNfaToSvgFormat(nfa) {
        if (!nfa || !nfa.states) {
          return { vertices: [], edges: [] };
        }
        const states = Array.from(nfa.states);
        const vertices = [];
        const edges = [];
        states.forEach((state, index) => {
          const numStates = states.length;
          let x, y;
          if (numStates === 1) {
            x = 400; y = 225;
          } else if (numStates === 2) {
            x = index === 0 ? 300 : 500;
            y = 225;
          } else {
            const angle = (2 * Math.PI * index) / numStates;
            const rad = Math.min(200, 150 + numStates * 10);
            x = 400 + rad * Math.cos(angle);
            y = 225 + rad * Math.sin(angle);
          }
          let type = "none";
          if (state === nfa.start) type = "start";
          if (state.isAccept) type = "accept";
          vertices.push({
            text: state.id.toString(),
            type: type,
            x: x,
            y: y
          });
        });
        states.forEach(state => {
          for (const [symbol, nextStates] of state.transitions) {
            for (const nextState of nextStates) {
              edges.push({
                start: state.id.toString(),
                end: nextState.id.toString(),
                text: symbol,
                type: "forward"
              });
            }
          }
          for (const nextState of state.epsilonTransitions) {
            edges.push({
              start: state.id.toString(),
              end: nextState.id.toString(),
              text: "ε",
              type: "forward"
            });
          }
        });
        return { vertices, edges };
      }
    }

    let converter = new StepByStepConverter();
    let allSteps = [];
    let currentStep = 0;
    let finalNFA = null;

    const examples = ['a*', 'a|b', 'ab', '(a|b)*', '(a|b)*abb', 'a+b*', '(ab)*'];

    function showInputDialog() {
      swal({
        title: "Enter Regular Expression",
        content: {
          element: "input",
          attributes: {
            placeholder: "e.g., (a|b)*abb",
            type: "text",
          },
        },
        button: {
          text: "Start Construction",
          closeModal: false,
        },
      })
      .then((regex) => {
        if (!regex || !regex.trim()) {
          swal.showInputError("Please enter a valid regular expression!");
          return false;
        }
        swal.close();
        startConstruction(regex.trim());
      });
    }

    function loadExample() {
      const randomExample = examples[Math.floor(Math.random() * examples.length)];
      startConstruction(randomExample);
    }

    function startConstruction(regex) {
      try {
        converter = new StepByStepConverter();
        allSteps = converter.parseRegex(regex);
        currentStep = 0;
        
        const lastStep = allSteps[allSteps.length - 1];
        finalNFA = lastStep && lastStep.nfa ? lastStep.nfa : null;
        
        // Update display
        document.getElementById('regex-display').textContent = regex;
        document.getElementById('progress-container').classList.remove('hidden');
        document.getElementById('test-section').classList.remove('hidden');
        
        setupStepDisplay();
        showCurrentStep();
        
      } catch (error) {
        console.error('Construction error:', error);
        swal("Error", "Error parsing regular expression: " + (error.message || 'Unknown error'), "error");
      }
    }

    function setupStepDisplay() {
      const stepsList = document.getElementById('steps-list');
      if (!stepsList || !allSteps) return;

      stepsList.innerHTML = '';

      allSteps.forEach((step, index) => {
        if (!step) return;

        const stepDiv = document.createElement('div');
        stepDiv.className = 'step-item';
        stepDiv.id = `step-${index}`;
        
        stepDiv.innerHTML = `
          <div class="flex items-start">
            <span class="step-number">${index + 1}</span>
            <div class="flex-1">
              <div class="font-medium text-sm">${step.title || 'Unknown Step'}</div>
              <div class="text-xs text-gray-600 mt-1">${step.description || 'No description'}</div>
            </div>
          </div>
        `;
        
        stepsList.appendChild(stepDiv);
      });
    }

    function displayCanvas(canvas, nfa, inputPointer, currentStates) {
      clearElem(canvas);
      const defs = newElementNS("defs", []);
      const marker = newElementNS("marker", [
        ["id", "arrowhead"], ["markerWidth", "7"], ["markerHeight", "5"],
        ["refX", "6"], ["refY", "2.5"], ["orient", "auto"], ["markerUnits", "strokeWidth"]
      ]);
      const arrowPath = newElementNS("path", [
        ["d", "M0,0 L7,2.5 L0,5 L2,2.5 Z"],
        ["fill", "#3B82F6"], ["stroke", "#3B82F6"], ["stroke-width", "0.5"]
      ]);
      marker.appendChild(arrowPath);
      defs.appendChild(marker);
      canvas.appendChild(defs);
      if (!nfa || !nfa.vertices || nfa.vertices.length === 0) {
        const text = newElementNS("text", [
          ["x", width/2], ["y", height/2],
          ["text-anchor", "middle"], ["dominant-baseline", "middle"],
          ["font-family", "Inter, sans-serif"], ["font-size", "16"],
          ["fill", "#6b7280"]
        ]);
        text.textContent = "No NFA data to display";
        canvas.appendChild(text);
        return;
      }
      const nodes = nfa.vertices;
      const edges = nfa.edges || [];
      let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
      nodes.forEach(n => {
        minX = Math.min(minX, n.x - radius);
        maxX = Math.max(maxX, n.x + radius);
        minY = Math.min(minY, n.y - radius);
        maxY = Math.max(maxY, n.y + radius);
      });
      minX -= 50; maxX += 50; minY -= 30; maxY += 30;
      const contentW = maxX - minX;
      const contentH = maxY - minY;
      const scaleX = width / contentW;
      const scaleY = height / contentH;
      const scale = Math.min(scaleX, scaleY, 1.0);
      const tx = (width - contentW * scale) / 2 - minX * scale;
      const ty = (height - contentH * scale) / 2 - minY * scale;
      const g = newElementNS("g", [["transform", `translate(${tx},${ty}) scale(${scale})`]]);
      canvas.appendChild(g);
      edges.forEach((edge, idx) => {
        const startNode = nodes.find(n => n.text === edge.start);
        const endNode = nodes.find(n => n.text === edge.end);
        if (!startNode || !endNode) return;
        let pathD, labelPos = {x: 0, y: 0};
        const isEpsilon = edge.text === "ε";
        if (startNode === endNode) {
          const x = startNode.x;
          const y = startNode.y - radius - 5;
          const r = 15;
          pathD = `M ${x} ${y} A ${r} ${r} 0 1 1 ${x - 0.1} ${y}`;
          labelPos = { x: x, y: y - r - 10 };
        } else {
          const angle = Math.atan2(endNode.y - startNode.y, endNode.x - startNode.x);
          const start = {
            x: startNode.x + radius * Math.cos(angle),
            y: startNode.y + radius * Math.sin(angle)
          };
          const end = {
            x: endNode.x - radius * Math.cos(angle),
            y: endNode.y - radius * Math.sin(angle)
          };
          const hasReverse = edges.some(e => e.start === edge.end && e.end === edge.start);
          const curveFactor = hasReverse ? 25 : (isEpsilon ? 15 : 10);
          pathD = createCurvedPath(start, end, curveFactor);
          const midX = (start.x + end.x) / 2;
          const midY = (start.y + end.y) / 2;
          if (curveFactor !== 0) {
            labelPos.x = midX + Math.sin(angle) * curveFactor;
            labelPos.y = midY - Math.cos(angle) * curveFactor;
          } else {
            labelPos = { x: midX, y: midY };
          }
        }
        const pathEl = newElementNS("path", [
          ["d", pathD], ["fill", "none"],
          ["stroke", isEpsilon ? "#888" : "#3B82F6"], ["stroke-width", "2"],
          ["marker-end", "url(#arrowhead)"]
        ]);
        if (isEpsilon) pathEl.setAttribute("stroke-dasharray", "5,3");
        g.appendChild(pathEl);
        const textEl = newElementNS("text", [
          ["x", labelPos.x], ["y", labelPos.y - 8],
          ["fill", isEpsilon ? "#555" : "#3B82F6"], ["font-family", "Inter, sans-serif"],
          ["font-size", "13"], ["font-weight", "600"],
          ["text-anchor", "middle"], ["dominant-baseline", "middle"]
        ]);
        textEl.textContent = edge.text;
        g.appendChild(textEl);
      });
      nodes.forEach(n => {
        const isActive = currentStates && currentStates.includes(n.text);
        let fill = "#fff", stroke = "#3B82F6", strokeWidth = "2";
        if (isActive) {
          fill = "#fef3c7";
          stroke = "#f59e0b";
          strokeWidth = "3";
        }
        const circle = newElementNS("circle", [
          ["cx", n.x], ["cy", n.y], ["r", radius],
          ["fill", fill], ["stroke", stroke], ["stroke-width", strokeWidth]
        ]);
        g.appendChild(circle);
        if (n.type === "accept") {
          const innerCircle = newElementNS("circle", [
            ["cx", n.x], ["cy", n.y], ["r", radius - 6],
            ["fill", "none"], ["stroke", stroke], ["stroke-width", "1.5"]
          ]);
          g.appendChild(innerCircle);
        }
        const label = newElementNS("text", [
          ["x", n.x], ["y", n.y + 2], ["fill", "#1f2937"],
          ["text-anchor", "middle"], ["dominant-baseline", "middle"],
          ["font-family", "Inter, sans-serif"], ["font-size", "14"], ["font-weight", "700"]
        ]);
        label.textContent = n.text;
        g.appendChild(label);
      });
      nodes.filter(n => n.type === "start").forEach(n => {
        const arrow = newElementNS("path", [
          ["d", `M ${n.x - radius - 30},${n.y} L ${n.x - radius - 5},${n.y}`],
          ["stroke", "#10B981"], ["stroke-width", "3"],
          ["marker-end", "url(#arrowhead)"]
        ]);
        g.appendChild(arrow);
      });
    }

    function clearElem(elem) {
      while (elem.firstChild) elem.removeChild(elem.lastChild);
    }
    function createCurvedPath(start, end, curveFactor) {
      if (Math.abs(curveFactor) < 5) {
        return `M ${start.x} ${start.y} L ${end.x} ${end.y}`;
      }
      const angle = Math.atan2(end.y - start.y, end.x - start.x);
      const mid = {
        x: (start.x + end.x) / 2 + Math.sin(angle) * curveFactor,
        y: (start.y + end.y) / 2 - Math.cos(angle) * curveFactor
      };
      return `M ${start.x} ${start.y} Q ${mid.x} ${mid.y} ${end.x} ${end.y}`;
    }
    function newElementNS(tag, attr) {
      const elem = document.createElementNS("http://www.w3.org/2000/svg", tag);
      attr.forEach(([name, value]) => elem.setAttribute(name, value));
      return elem;
    }

    function refreshCanvas() {
      const svg = document.getElementById("canvas1");
      if (!svg) return;
      const parent = svg.parentElement;
      const w = parent.offsetWidth || 800;
      const h = Math.max(280, Math.round(w / 2.8));
      svg.setAttribute("width", w);
      svg.setAttribute("height", h);
      width = w;
      height = h;
      const nfaDef = converter.getSvgDefinitionForStep(currentStep);
      const currStates = converter.getClosureStatesForStep(currentStep);
      displayCanvas(svg, nfaDef, 0, currStates);
    }

    function showCurrentStep() {
      if (!allSteps || allSteps.length === 0 || currentStep < 0 || currentStep >= allSteps.length) {
        return;
      }
      const step = allSteps[currentStep];
      if (!step) return;
      document.getElementById('current-step-title').textContent = step.title || 'Unknown Step';
      document.getElementById('current-step-description').textContent = step.description || 'No description';
      document.getElementById('step-counter').textContent = `${currentStep + 1} / ${allSteps.length}`;
      const progress = ((currentStep + 1) / allSteps.length) * 100;
      document.getElementById('progress-fill').style.width = `${progress}%`;
      allSteps.forEach((_, index) => {
        const stepElement = document.getElementById(`step-${index}`);
        if (stepElement) {
          stepElement.classList.remove('current', 'completed');
          if (index === currentStep) {
            stepElement.classList.add('current');
          } else if (index < currentStep) {
            stepElement.classList.add('completed');
          }
        }
      });
      document.getElementById('prev-btn').disabled = currentStep === 0;
      const nextBtn = document.getElementById('next-btn');
      nextBtn.disabled = currentStep === allSteps.length - 1;
      nextBtn.innerHTML = currentStep === allSteps.length - 1 ? 
        '<svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path></svg>Complete' :
        '<svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd"></path></svg>Next Step';
      refreshCanvas();
      const currentStepElement = document.getElementById(`step-${currentStep}`);
      if (currentStepElement) {
        currentStepElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      }
    }

    function nextStep() {
      if (currentStep < allSteps.length - 1) {
        currentStep++;
        showCurrentStep();
      }
    }

    function previousStep() {
      if (currentStep > 0) {
        currentStep--;
        showCurrentStep();
      }
    }

    function testString() {
      const testInput = document.getElementById('test-input').value;
      const resultDiv = document.getElementById('test-result');

      if (!finalNFA) {
        resultDiv.innerHTML = '<div class="text-red-600 text-sm">Please complete the construction first</div>';
        return;
      }

      const accepted = finalNFA.accepts(testInput);
      const resultClass = accepted ? 'text-green-600 bg-green-50 border-green-200' : 'text-red-600 bg-red-50 border-red-200';
      const resultText = accepted ? 'ACCEPTED' : 'REJECTED';
      
      resultDiv.innerHTML = `
        <div class="${resultClass} border rounded p-2 text-sm font-medium">
          "${testInput}" is ${resultText}
        </div>
      `;
    }

    // Keyboard shortcuts
    document.addEventListener('keydown', function(e) {
      if (document.getElementById('progress-container').classList.contains('hidden')) return;
      
      if (e.key === 'ArrowRight' && !document.getElementById('next-btn').disabled) {
        nextStep();
      } else if (e.key === 'ArrowLeft' && !document.getElementById('prev-btn').disabled) {
        previousStep();
      }
    });

    // Add resize handler for responsive SVG
    window.addEventListener('resize', refreshCanvas);
    window.addEventListener('load', function() {
      setTimeout(() => {
        if (document.getElementById('canvas1')) {
          refreshCanvas();
        }
      }, 100);
    });

    // Start with an example on load
    window.addEventListener('load', function() {
      setTimeout(() => loadExample(), 500);
    });

    // Global variables for SVG rendering
    let width = 800;
    let height = 450;
    let radius = 28;
  </script>
<script src="../assets/js/iframeResize.js"></script>
        
        </body>
</html>