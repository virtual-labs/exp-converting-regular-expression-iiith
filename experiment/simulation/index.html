<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RegEx to NFA Converter - Step by Step</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4f46e5, #7c3aed);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .content {
            padding: 30px;
        }

        .input-section {
            background: #f8fafc;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            border: 2px solid #e2e8f0;
        }

        .input-group {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-bottom: 20px;
        }

        label {
            font-weight: 600;
            color: #374151;
            min-width: 120px;
        }

        input[type="text"] {
            flex: 1;
            padding: 12px 16px;
            border: 2px solid #d1d5db;
            border-radius: 10px;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }

        .btn {
            background: linear-gradient(135deg, #4f46e5, #7c3aed);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(79, 70, 229, 0.3);
        }

        .btn:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .examples {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .example-btn {
            background: #e0e7ff;
            color: #4338ca;
            border: 1px solid #c7d2fe;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .example-btn:hover {
            background: #c7d2fe;
        }

        .step-by-step-section {
            background: #f8fafc;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            border: 2px solid #e2e8f0;
        }

        .step-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .step-info {
            flex: 1;
            min-width: 200px;
        }

        .current-step {
            font-size: 1.2rem;
            font-weight: 600;
            color: #374151;
            margin-bottom: 5px;
        }

        .step-description {
            color: #6b7280;
            font-size: 14px;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e5e7eb;
            border-radius: 4px;
            margin: 15px 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #4f46e5, #7c3aed);
            transition: width 0.3s ease;
        }

        .main-display {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 30px;
            margin-top: 20px;
        }

        .nfa-display {
            background: white;
            border-radius: 15px;
            padding: 20px;
            border: 2px solid #e2e8f0;
        }

        .nfa-display h3 {
            color: #374151;
            margin-bottom: 15px;
            font-size: 1.3rem;
            font-weight: 600;
        }

        #step-canvas {
            border: 2px solid #d1d5db;
            border-radius: 10px;
            background: white;
            width: 100%;
            height: 400px;
        }

        .step-panel {
            background: white;
            border-radius: 15px;
            padding: 20px;
            border: 2px solid #e2e8f0;
            max-height: 500px;
            overflow-y: auto;
        }

        .step-panel h3 {
            color: #374151;
            margin-bottom: 15px;
            font-size: 1.3rem;
            font-weight: 600;
        }

        .step-item {
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            transition: all 0.3s ease;
        }

        .step-item.current {
            background: #eff6ff;
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
        }

        .step-item.completed {
            background: #f0fdf4;
            border-color: #10b981;
        }

        .step-title {
            font-weight: 600;
            color: #374151;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .step-number {
            background: #6b7280;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
        }

        .step-item.current .step-number {
            background: #3b82f6;
        }

        .step-item.completed .step-number {
            background: #10b981;
        }

        .step-details {
            color: #6b7280;
            font-size: 14px;
            line-height: 1.5;
        }

        .stack-display {
            background: #fef3c7;
            border: 1px solid #f59e0b;
            border-radius: 6px;
            padding: 10px;
            margin-top: 8px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }

        .error {
            background: #fef2f2;
            border: 2px solid #fecaca;
            color: #dc2626;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .test-section {
            background: #f0fdf4;
            border: 2px solid #bbf7d0;
            border-radius: 15px;
            padding: 25px;
            margin-top: 30px;
        }

        .test-section h3 {
            color: #166534;
            margin-bottom: 20px;
        }

        .test-result {
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            font-weight: 600;
        }

        .test-accept {
            background: #dcfce7;
            color: #166534;
            border: 1px solid #bbf7d0;
        }

        .test-reject {
            background: #fef2f2;
            color: #dc2626;
            border: 1px solid #fecaca;
        }

        @media (max-width: 1024px) {
            .main-display {
                grid-template-columns: 1fr;
            }
            
            .input-group {
                flex-direction: column;
                align-items: stretch;
            }
            
            .step-controls {
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>RegEx ‚Üí NFA Step-by-Step</h1>
            <p>Watch Thompson's construction algorithm build the NFA step by step</p>
        </div>

        <div class="content">
            <div class="input-section">
                <div class="input-group">
                    <label for="regex-input">Regular Expression:</label>
                    <input type="text" id="regex-input" placeholder="Enter a regular expression (e.g., (a|b)*abb)" value="a*b">
                    <button class="btn" onclick="startConstruction()">Start Construction</button>
                </div>
                
                <div>
                    <label style="margin-bottom: 10px; display: block;">Examples:</label>
                    <div class="examples">
                        <button class="example-btn" onclick="setExample('a*')">a*</button>
                        <button class="example-btn" onclick="setExample('a|b')">a|b</button>
                        <button class="example-btn" onclick="setExample('ab')">ab</button>
                        <button class="example-btn" onclick="setExample('(a|b)*')">(a|b)*</button>
                        <button class="example-btn" onclick="setExample('(a|b)*abb')">(a|b)*abb</button>
                    </div>
                </div>
            </div>

            <div id="error-container"></div>

            <div class="step-by-step-section" id="step-section" style="display: none;">
                <div class="step-controls">
                    <div class="step-info">
                        <div class="current-step" id="current-step-title">Ready to begin</div>
                        <div class="step-description" id="current-step-description">Click "Next Step" to start the construction</div>
                    </div>
                    <button class="btn" id="prev-btn" onclick="previousStep()" disabled>‚Üê Previous</button>
                    <button class="btn" id="next-btn" onclick="nextStep()">Next Step ‚Üí</button>
                    <button class="btn" onclick="autoPlay()" id="auto-btn">‚ñ∂ Auto Play</button>
                </div>

                <div class="progress-bar">
                    <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
                </div>

                <div class="main-display">
                    <div class="nfa-display">
                        <h3>üìä NFA Construction</h3>
                        <canvas id="step-canvas"></canvas>
                    </div>
                    
                    <div class="step-panel">
                        <h3>üîÑ Construction Steps</h3>
                        <div id="steps-list"></div>
                    </div>
                </div>
            </div>

            <div class="test-section" id="test-section" style="display: none;">
                <h3>üß™ Test the Final NFA</h3>
                <div class="input-group">
                    <label for="test-input">Test String:</label>
                    <input type="text" id="test-input" placeholder="Enter a string to test">
                    <button class="btn" onclick="testString()">Test</button>
                </div>
                <div id="test-result"></div>
            </div>
        </div>
    </div>

    <script>
        class NFAState {
            constructor(id) {
                this.id = id;
                this.transitions = new Map();
                this.epsilonTransitions = new Set();
                this.isAccept = false;
            }

            addTransition(symbol, state) {
                if (!this.transitions.has(symbol)) {
                    this.transitions.set(symbol, new Set());
                }
                this.transitions.get(symbol).add(state);
            }

            addEpsilonTransition(state) {
                this.epsilonTransitions.add(state);
            }
        }

        class NFA {
            constructor(start, accept) {
                this.start = start;
                this.accept = accept;
                
                if (accept) {
                    accept.isAccept = true;
                }
                
                this.states = new Set();
                this.alphabet = new Set();
                
                if (start) {
                    this.collectStates(start);
                }
            }

            collectStates(state, visited = new Set()) {
                if (!state || visited.has(state)) return;
                visited.add(state);
                this.states.add(state);

                // Safely iterate through transitions
                if (state.transitions && state.transitions instanceof Map) {
                    for (const [symbol, nextStates] of state.transitions) {
                        if (symbol) this.alphabet.add(symbol);
                        if (nextStates) {
                            for (const nextState of nextStates) {
                                if (nextState) {
                                    this.collectStates(nextState, visited);
                                }
                            }
                        }
                    }
                }

                // Safely iterate through epsilon transitions
                if (state.epsilonTransitions) {
                    for (const nextState of state.epsilonTransitions) {
                        if (nextState) {
                            this.collectStates(nextState, visited);
                        }
                    }
                }
            }

            epsilonClosure(states) {
                const closure = new Set(states);
                const stack = [...states];

                while (stack.length > 0) {
                    const state = stack.pop();
                    for (const epsilonState of state.epsilonTransitions) {
                        if (!closure.has(epsilonState)) {
                            closure.add(epsilonState);
                            stack.push(epsilonState);
                        }
                    }
                }

                return closure;
            }

            accepts(input) {
                let currentStates = this.epsilonClosure(new Set([this.start]));

                for (const symbol of input) {
                    const nextStates = new Set();
                    for (const state of currentStates) {
                        if (state.transitions.has(symbol)) {
                            for (const nextState of state.transitions.get(symbol)) {
                                nextStates.add(nextState);
                            }
                        }
                    }
                    currentStates = this.epsilonClosure(nextStates);
                }

                return Array.from(currentStates).some(state => state.isAccept);
            }
        }

        class StepByStepConverter {
            constructor() {
                this.stateCounter = 0;
                this.steps = [];
                this.currentStepIndex = 0;
                this.isAutoPlaying = false;
            }

            createState() {
                return new NFAState(this.stateCounter++);
            }

            reset() {
                this.stateCounter = 0;
                this.steps = [];
                this.currentStepIndex = 0;
                this.isAutoPlaying = false;
            }

            parseRegex(regex) {
                this.reset();
                
                // Step 1: Show original regex
                this.steps.push({
                    title: "Original Regular Expression",
                    description: `Input regex: ${regex}`,
                    nfa: null,
                    stack: [],
                    operation: "start"
                });

                // Step 2: Tokenize
                const tokens = this.tokenize(regex);
                this.steps.push({
                    title: "Tokenization",
                    description: `Broke regex into tokens: [${tokens.join(', ')}]`,
                    nfa: null,
                    stack: [],
                    operation: "tokenize",
                    tokens: tokens
                });

                // Step 3: Convert to postfix
                const postfix = this.infixToPostfix(tokens);
                this.steps.push({
                    title: "Convert to Postfix",
                    description: `Converted to postfix notation: [${postfix.join(', ')}]`,
                    nfa: null,
                    stack: [],
                    operation: "postfix",
                    postfix: postfix
                });

                // Step 4: Build NFA step by step
                this.buildNFAStepByStep(postfix);

                return this.steps;
            }

            tokenize(regex) {
                const tokens = [];
                for (let i = 0; i < regex.length; i++) {
                    const char = regex[i];
                    tokens.push(char);
                }
                return tokens;
            }

            infixToPostfix(tokens) {
                const output = [];
                const stack = [];
                const precedence = { '|': 1, '¬∑': 2, '*': 3, '+': 3 };

                // Add concatenation operators
                const withConcat = [];
                for (let i = 0; i < tokens.length; i++) {
                    withConcat.push(tokens[i]);
                    if (i < tokens.length - 1) {
                        const curr = tokens[i];
                        const next = tokens[i + 1];
                        if (!'(|'.includes(curr) && !')|*+'.includes(next)) {
                            withConcat.push('¬∑');
                        }
                    }
                }

                for (const token of withConcat) {
                    if (token === '(') {
                        stack.push(token);
                    } else if (token === ')') {
                        while (stack.length && stack[stack.length - 1] !== '(') {
                            output.push(stack.pop());
                        }
                        stack.pop();
                    } else if ('|¬∑*+'.includes(token)) {
                        while (stack.length && stack[stack.length - 1] !== '(' &&
                               precedence[stack[stack.length - 1]] >= precedence[token]) {
                            output.push(stack.pop());
                        }
                        stack.push(token);
                    } else {
                        output.push(token);
                    }
                }

                while (stack.length) {
                    output.push(stack.pop());
                }

                return output;
            }

            buildNFAStepByStep(postfix) {
                const stack = [];

                for (const token of postfix) {
                    if (token === '|') {
                        const nfa2 = stack.pop();
                        const nfa1 = stack.pop();
                        const result = this.union(nfa1, nfa2);
                        stack.push(result);
                        
                        this.steps.push({
                            title: "Union Operation (|)",
                            description: `Combined two NFAs with union operator. Created new start and accept states with Œµ-transitions.`,
                            nfa: result,
                            stack: [...stack],
                            operation: "union",
                            operands: [nfa1, nfa2]
                        });
                    } else if (token === '¬∑') {
                        const nfa2 = stack.pop();
                        const nfa1 = stack.pop();
                        const result = this.concatenation(nfa1, nfa2);
                        stack.push(result);
                        
                        this.steps.push({
                            title: "Concatenation Operation (¬∑)",
                            description: `Connected two NFAs in sequence with Œµ-transition from first accept to second start.`,
                            nfa: result,
                            stack: [...stack],
                            operation: "concat",
                            operands: [nfa1, nfa2]
                        });
                    } else if (token === '*') {
                        const nfa = stack.pop();
                        const result = this.kleeneStar(nfa);
                        stack.push(result);
                        
                        this.steps.push({
                            title: "Kleene Star Operation (*)",
                            description: `Applied * operator. Created new start/accept states with Œµ-transitions for zero or more repetitions.`,
                            nfa: result,
                            stack: [...stack],
                            operation: "star",
                            operands: [nfa]
                        });
                    } else if (token === '+') {
                        const nfa = stack.pop();
                        const result = this.plus(nfa);
                        stack.push(result);
                        
                        this.steps.push({
                            title: "Plus Operation (+)",
                            description: `Applied + operator. Modified for one or more repetitions (no direct path to accept).`,
                            nfa: result,
                            stack: [...stack],
                            operation: "plus",
                            operands: [nfa]
                        });
                    } else {
                        const result = this.symbol(token);
                        stack.push(result);
                        
                        this.steps.push({
                            title: `Symbol NFA for '${token}'`,
                            description: `Created basic NFA with start state, accept state, and transition on symbol '${token}'.`,
                            nfa: result,
                            stack: [...stack],
                            operation: "symbol",
                            symbol: token
                        });
                    }
                }

                this.steps.push({
                    title: "Construction Complete!",
                    description: `Successfully converted regular expression to NFA. The final NFA has ${stack[0].states.size} states.`,
                    nfa: stack[0],
                    stack: stack,
                    operation: "complete"
                });
            }

            symbol(char) {
                const start = this.createState();
                const accept = this.createState();
                start.addTransition(char, accept);
                return new NFA(start, accept);
            }

            concatenation(nfa1, nfa2) {
                nfa1.accept.addEpsilonTransition(nfa2.start);
                nfa1.accept.isAccept = false;
                return new NFA(nfa1.start, nfa2.accept);
            }

            union(nfa1, nfa2) {
                const start = this.createState();
                const accept = this.createState();

                start.addEpsilonTransition(nfa1.start);
                start.addEpsilonTransition(nfa2.start);

                nfa1.accept.addEpsilonTransition(accept);
                nfa2.accept.addEpsilonTransition(accept);

                nfa1.accept.isAccept = false;
                nfa2.accept.isAccept = false;

                return new NFA(start, accept);
            }

            kleeneStar(nfa) {
                const start = this.createState();
                const accept = this.createState();

                start.addEpsilonTransition(nfa.start);
                start.addEpsilonTransition(accept);

                nfa.accept.addEpsilonTransition(nfa.start);
                nfa.accept.addEpsilonTransition(accept);

                nfa.accept.isAccept = false;

                return new NFA(start, accept);
            }

            plus(nfa) {
                const start = this.createState();
                const accept = this.createState();

                start.addEpsilonTransition(nfa.start);
                nfa.accept.addEpsilonTransition(nfa.start);
                nfa.accept.addEpsilonTransition(accept);

                nfa.accept.isAccept = false;

                return new NFA(start, accept);
            }
        }

        let converter = new StepByStepConverter();
        let allSteps = [];
        let currentStep = 0;
        let finalNFA = null;

        function setExample(regex) {
            document.getElementById('regex-input').value = regex;
        }

        function startConstruction() {
            const regex = document.getElementById('regex-input').value.trim();
            const errorContainer = document.getElementById('error-container');
            const stepSection = document.getElementById('step-section');
            const testSection = document.getElementById('test-section');

            // Clear previous errors
            if (errorContainer) errorContainer.innerHTML = '';

            if (!regex) {
                showError('Please enter a regular expression');
                return;
            }

            try {
                // Reset converter and get steps
                converter = new StepByStepConverter();
                allSteps = converter.parseRegex(regex);
                currentStep = 0;
                
                // Get final NFA (last step should have the complete NFA)
                const lastStep = allSteps[allSteps.length - 1];
                finalNFA = lastStep && lastStep.nfa ? lastStep.nfa : null;
                
                // Setup display
                setupStepDisplay();
                
                // Show sections
                if (stepSection) stepSection.style.display = 'block';
                if (testSection) testSection.style.display = 'block';
                
                // Show first step
                showCurrentStep();
                
            } catch (error) {
                console.error('Construction error:', error);
                showError('Error parsing regular expression: ' + (error.message || 'Unknown error'));
                if (stepSection) stepSection.style.display = 'none';
                if (testSection) testSection.style.display = 'none';
            }
        }

        function setupStepDisplay() {
            const stepsList = document.getElementById('steps-list');
            if (!stepsList || !allSteps) return;

            stepsList.innerHTML = '';

            allSteps.forEach((step, index) => {
                if (!step) return;

                const stepDiv = document.createElement('div');
                stepDiv.className = 'step-item';
                stepDiv.id = `step-${index}`;
                
                const stackInfo = step.stack && step.stack.length > 0 
                    ? `<div class="stack-display">Stack: [${step.stack.map(nfa => nfa && nfa.states ? `NFA(${nfa.states.size} states)` : 'Invalid NFA').join(', ')}]</div>`
                    : '';
                
                stepDiv.innerHTML = `
                    <div class="step-title">
                        <span class="step-number">${index + 1}</span>
                        ${step.title || 'Unknown Step'}
                    </div>
                    <div class="step-details">
                        ${step.description || 'No description'}
                        ${stackInfo}
                    </div>
                `;
                
                stepsList.appendChild(stepDiv);
            });
        }

        function showCurrentStep() {
            if (!allSteps || allSteps.length === 0 || currentStep < 0 || currentStep >= allSteps.length) {
                console.error('Invalid step data:', { allSteps, currentStep });
                return;
            }

            const step = allSteps[currentStep];
            if (!step) {
                console.error('Invalid step at index:', currentStep);
                return;
            }
            
            // Update step info
            const titleElement = document.getElementById('current-step-title');
            const descElement = document.getElementById('current-step-description');
            
            if (titleElement) titleElement.textContent = step.title || 'Unknown Step';
            if (descElement) descElement.textContent = step.description || 'No description';
            
            // Update progress
            const progress = ((currentStep + 1) / allSteps.length) * 100;
            const progressElement = document.getElementById('progress-fill');
            if (progressElement) {
                progressElement.style.width = `${progress}%`;
            }
            
            // Update step items
            allSteps.forEach((_, index) => {
                const stepElement = document.getElementById(`step-${index}`);
                if (stepElement) {
                    stepElement.classList.remove('current', 'completed');
                    
                    if (index === currentStep) {
                        stepElement.classList.add('current');
                    } else if (index < currentStep) {
                        stepElement.classList.add('completed');
                    }
                }
            });
            
            // Update buttons
            const prevBtn = document.getElementById('prev-btn');
            const nextBtn = document.getElementById('next-btn');
            
            if (prevBtn) prevBtn.disabled = currentStep === 0;
            if (nextBtn) {
                nextBtn.disabled = currentStep === allSteps.length - 1;
                nextBtn.textContent = currentStep === allSteps.length - 1 ? 'Complete ‚úì' : 'Next Step ‚Üí';
            }
            
            // Draw NFA with error handling
            try {
                drawCurrentNFA();
            } catch (error) {
                console.error('Error drawing NFA:', error);
            }
            
            // Scroll to current step
            const currentStepElement = document.getElementById(`step-${currentStep}`);
            if (currentStepElement) {
                try {
                    currentStepElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                } catch (error) {
                    // Fallback for older browsers
                    currentStepElement.scrollIntoView(false);
                }
            }
        }

        function nextStep() {
            if (currentStep < allSteps.length - 1) {
                currentStep++;
                showCurrentStep();
            }
        }

        function previousStep() {
            if (currentStep > 0) {
                currentStep--;
                showCurrentStep();
            }
        }

        function autoPlay() {
            const btn = document.getElementById('auto-btn');
            
            if (converter.isAutoPlaying) {
                converter.isAutoPlaying = false;
                btn.textContent = '‚ñ∂ Auto Play';
                btn.style.background = 'linear-gradient(135deg, #4f46e5, #7c3aed)';
            } else {
                converter.isAutoPlaying = true;
                btn.textContent = '‚è∏ Pause';
                btn.style.background = 'linear-gradient(135deg, #ef4444, #dc2626)';
                autoPlayNext();
            }
        }

        function autoPlayNext() {
            if (!converter.isAutoPlaying) return;
            
            if (currentStep < allSteps.length - 1) {
                nextStep();
                setTimeout(autoPlayNext, 2000); // 2 second delay
            } else {
                converter.isAutoPlaying = false;
                const btn = document.getElementById('auto-btn');
                btn.textContent = '‚ñ∂ Auto Play';
                btn.style.background = 'linear-gradient(135deg, #4f46e5, #7c3aed)';
            }
        }

        function drawCurrentNFA() {
            const canvas = document.getElementById('step-canvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            if (!ctx) return;
            
            canvas.width = canvas.offsetWidth || 800;
            canvas.height = canvas.offsetHeight || 400;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (!allSteps || currentStep >= allSteps.length) {
                ctx.fillStyle = '#6b7280';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('No data to display', canvas.width / 2, canvas.height / 2);
                return;
            }

            const step = allSteps[currentStep];
            if (!step || !step.nfa) {
                // Show text for non-NFA steps
                ctx.fillStyle = '#6b7280';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                const text = step ? step.description : 'Loading...';
                ctx.fillText(text, canvas.width / 2, canvas.height / 2);
                return;
            }

            const nfa = step.nfa;
            if (!nfa || !nfa.states) {
                ctx.fillStyle = '#dc2626';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Error: Invalid NFA data', canvas.width / 2, canvas.height / 2);
                return;
            }

            const states = Array.from(nfa.states);
            const positions = new Map();
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(canvas.width, canvas.height) * 0.25;

            // Position states in a circle
            if (states.length === 1) {
                positions.set(states[0], { x: centerX, y: centerY });
            } else if (states.length === 2) {
                positions.set(states[0], { x: centerX - 80, y: centerY });
                positions.set(states[1], { x: centerX + 80, y: centerY });
            } else {
                states.forEach((state, index) => {
                    const angle = (2 * Math.PI * index) / states.length;
                    const x = centerX + radius * Math.cos(angle);
                    const y = centerY + radius * Math.sin(angle);
                    positions.set(state, { x, y });
                });
            }

            // Draw transitions
            ctx.strokeStyle = '#4f46e5';
            ctx.lineWidth = 2;
            
            states.forEach(state => {
                const fromPos = positions.get(state);
                if (!fromPos) return; // Skip if state position not found
                
                // Draw symbol transitions
                for (const [symbol, nextStates] of state.transitions) {
                    for (const nextState of nextStates) {
                        const toPos = positions.get(nextState);
                        if (toPos && fromPos) { // Only draw if both positions exist
                            drawArrow(ctx, fromPos.x, fromPos.y, toPos.x, toPos.y, symbol);
                        }
                    }
                }

                // Draw epsilon transitions
                for (const nextState of state.epsilonTransitions) {
                    const toPos = positions.get(nextState);
                    if (toPos && fromPos) { // Only draw if both positions exist
                        drawArrow(ctx, fromPos.x, fromPos.y, toPos.x, toPos.y, 'Œµ');
                    }
                }
            });

            // Draw states
            states.forEach(state => {
                const pos = positions.get(state);
                if (!pos || !nfa) return; // Skip if position not found
                
                ctx.fillStyle = state === nfa.start ? '#10b981' : 
                               state.isAccept ? '#ef4444' : '#6b7280';
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 20, 0, 2 * Math.PI);
                ctx.fill();

                // Double circle for accept states
                if (state.isAccept) {
                    ctx.strokeStyle = '#ef4444';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, 25, 0, 2 * Math.PI);
                    ctx.stroke();
                }

                // State label
                ctx.fillStyle = 'white';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                const stateId = state.id !== undefined ? state.id.toString() : '?';
                ctx.fillText(stateId, pos.x, pos.y + 4);
            });

            // Add legend
            ctx.fillStyle = '#374151';
            ctx.font = '12px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('‚óè Start State', 10, 20);
            ctx.fillStyle = '#ef4444';
            ctx.fillText('‚óè Accept State', 10, 35);
            ctx.fillStyle = '#4f46e5';
            ctx.fillText('‚Üí Transitions (Œµ = epsilon)', 10, 50);
        }

        function drawArrow(ctx, fromX, fromY, toX, toY, label) {
            if (!ctx || typeof fromX !== 'number' || typeof fromY !== 'number' || 
                typeof toX !== 'number' || typeof toY !== 'number') {
                return;
            }

            const dx = toX - fromX;
            const dy = toY - fromY;
            const length = Math.sqrt(dx * dx + dy * dy);
            
            if (length < 5) {
                // Self-loop or very close states
                ctx.save();
                ctx.strokeStyle = '#4f46e5';
                ctx.lineWidth = 2;
                
                ctx.beginPath();
                ctx.arc(fromX, fromY - 35, 15, 0, 2 * Math.PI);
                ctx.stroke();
                
                // Arrow on self-loop
                ctx.beginPath();
                ctx.moveTo(fromX + 10, fromY - 25);
                ctx.lineTo(fromX + 5, fromY - 20);
                ctx.moveTo(fromX + 10, fromY - 25);
                ctx.lineTo(fromX + 15, fromY - 20);
                ctx.stroke();
                
                // Label on self-loop
                ctx.fillStyle = '#4f46e5';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(label || '', fromX, fromY - 50);
                
                ctx.restore();
                return;
            }
            
            const unitX = dx / length;
            const unitY = dy / length;
            
            const startX = fromX + unitX * 25;
            const startY = fromY + unitY * 25;
            const endX = toX - unitX * 25;
            const endY = toY - unitY * 25;
            
            ctx.save();
            ctx.strokeStyle = '#4f46e5';
            ctx.lineWidth = 2;
            
            // Draw line
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.stroke();
            
            // Draw arrowhead
            const headSize = 10;
            const angle = Math.atan2(dy, dx);
            
            ctx.beginPath();
            ctx.moveTo(endX, endY);
            ctx.lineTo(
                endX - headSize * Math.cos(angle - Math.PI / 6),
                endY - headSize * Math.sin(angle - Math.PI / 6)
            );
            ctx.moveTo(endX, endY);
            ctx.lineTo(
                endX - headSize * Math.cos(angle + Math.PI / 6),
                endY - headSize * Math.sin(angle + Math.PI / 6)
            );
            ctx.stroke();
            
            // Draw label
            const midX = (startX + endX) / 2;
            const midY = (startY + endY) / 2;
            
            // Offset label to avoid overlapping with line
            const offsetX = -unitY * 15;
            const offsetY = unitX * 15;
            
            ctx.fillStyle = '#4f46e5';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(label || '', midX + offsetX, midY + offsetY);
            
            ctx.restore();
        }

        function testString() {
            const testInput = document.getElementById('test-input').value;
            const resultDiv = document.getElementById('test-result');

            if (!finalNFA) {
                resultDiv.innerHTML = '<div class="test-reject">Please complete the construction first</div>';
                return;
            }

            const accepted = finalNFA.accepts(testInput);
            const resultClass = accepted ? 'test-accept' : 'test-reject';
            const resultText = accepted ? 'ACCEPTED' : 'REJECTED';
            
            resultDiv.innerHTML = `
                <div class="${resultClass}">
                    String "${testInput}" is ${resultText}
                </div>
            `;
        }

        function showError(message) {
            const errorContainer = document.getElementById('error-container');
            errorContainer.innerHTML = `<div class="error">${message}</div>`;
        }

        // Auto-start with example on page load
        window.onload = function() {
            startConstruction();
        };

        // Handle Enter key in input fields
        document.getElementById('regex-input').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                startConstruction();
            }
        });

        document.getElementById('test-input').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                testString();
            }
        });

        // Handle keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            if (document.getElementById('step-section').style.display !== 'none') {
                if (e.key === 'ArrowRight' && !document.getElementById('next-btn').disabled) {
                    nextStep();
                } else if (e.key === 'ArrowLeft' && !document.getElementById('prev-btn').disabled) {
                    previousStep();
                } else if (e.key === ' ') {
                    e.preventDefault();
                    autoPlay();
                }
            }
        });
    </script>
</body>
</html>